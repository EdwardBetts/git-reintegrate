#!/usr/bin/env ruby

NULL_SHA1 = '0' * 40

def die(*args)
  fmt = args.shift
  $stderr.printf("fatal: %s\n" % fmt, *args)
  exit 128
end

class ParseOpt
  attr_writer :usage

  class Option
    attr_reader :short, :long, :help

    def initialize(short, long, help, &block)
      @block = block
      @short = short
      @long = long
      @help = help
    end

    def call(v)
      @block.call(v)
    end
  end

  def initialize
    @list = {}
  end

  def on(short = nil, long = nil, help = nil, &block)
    opt = Option.new(short, long, help, &block)
    @list[short] = opt if short
    @list[long] = opt if long
  end

  def parse
    if ARGV.member?('-h') or ARGV.member?('--help')
      usage
      exit 0
    end
    seen_dash = false
    ARGV.delete_if do |cur|
      opt = val = nil
      next false if cur[0,1] != '-' or seen_dash
      case cur
      when '--'
        seen_dash = true
        next true
      when /^--no-(.+)$/
        opt = @list[$1]
        val = false
      when /^-([^-])(.+)?$/, /^--(.+?)(?:=(.+))?$/
        opt = @list[$1]
        val = $2 || true
      end
      if opt
        opt.call(val)
        true
      else
        usage
        exit 1
      end
    end
  end

  def usage
    def fmt(prefix, str)
      return str ? prefix + str : nil
    end
    puts 'usage: %s' % @usage
    @list.values.uniq.each do |opt|
      s = '    '
      s << ''
      s << [fmt('-', opt.short), fmt('--', opt.long)].compact.join(', ')
      s << ''
      s << '%*s%s' % [26 - s.size, '', opt.help] if opt.help
      puts s
    end
  end

end

class Branch

  attr_reader :name, :ref, :int

  def initialize(name)
    @name = name
  end

  def get
    if @name
      @ref = %x[git rev-parse --symbolic-full-name "refs/heads/#{@name}"].chomp
      die "no such branch: #{@name}" unless $?.success?
    else
      @ref = %x[git symbolic-ref HEAD].chomp
      die "HEAD is detached, could not figure out which integration branch to use" unless $?.success?
      @name = @ref.gsub(%r{^refs/heads/}, '')
    end

    @int = @ref.gsub(%r{^refs/heads/}, 'refs/int/')

    system(*%w[git rev-parse --quiet --verify], @int, :out => File::NULL)
    die "Not an integration branch: #{@name}" unless $?.success?
  end

  def create(base = nil)
    @ref = %x[git check-ref-format --normalize "refs/heads/#{@name}"].chomp
    die "invalid branch name: #{@name}" unless $?.success?

    if base
      system(*%w[git rev-parse --quiet --verify], "#{base}^{commit}", :out => File::NULL)
      die "no such commit: #{base}" unless $?.success?
    else
      base = 'master'
    end

    @int = @ref.gsub(%r{^refs/heads/}, 'refs/int/')

    system(*%w[git update-ref], @ref, base, NULL_SHA1)
    write_instructions("base #{base}\n")
    system(*%w[git checkout], @name)
    puts "Integration branch #{@name} created."
  end

  def read_instructions
    %x[git cat-file blob #{@int}:instructions].chomp
  end

  def write_instructions(content)
    insn_blob = insn_tree = insn_commit = nil

    parent = %x[git rev-parse --quiet --verify #{@int}].chomp
    parent_tree = %x[git rev-parse --quiet --verify #{@int}^{tree}].chomp

    parent = nil if parent.empty?

    IO.popen(%[git hash-object -w --stdin], 'r+') do |io|
      io.write(content)
      io.close_write
      insn_blob = io.read.chomp
    end
    die "Failed to write instruction sheet blob object" unless $?.success?

    IO.popen(%[git mktree], 'r+') do |io|
      io.printf "100644 blob %s\t%s\n", insn_blob, 'instructions'
      io.close_write
      insn_tree = io.read.chomp
    end
    die "Failed to write instruction sheet tree object" unless $?.success?

    # If there isn't anything to commit, stop now.
    return if insn_tree == parent_tree

    op = parent ? 'Update' : 'Create'
    opts = parent ? ['-p', parent] : []
    opts << insn_tree
    IO.popen(%w[git commit-tree] + opts, 'r+') do |io|
      io.write("#{op} integration branch #{@int}")
      io.close_write
      insn_commit = io.read.chomp
    end
    die "Failed to write instruction sheet commit" unless $?.success?

    system(*%w[git update-ref], @int, insn_commit, parent || NULL_SHA1)
    die "Failed to update instruction sheet reference" unless $?.success?
  end

end

opts = ParseOpt.new
opts.usage = 'git reintegrate'

opts.on('c', 'create', 'create a new integration branch') do |v|
  $create = true
end

opts.parse

$branch = Branch.new(ARGV[0])
if $create
  $branch.create(ARGV[1])
else
  $branch.get
end
